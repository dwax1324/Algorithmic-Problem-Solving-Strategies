# 비트마스크를 이용한 집합의 구현  


### 예제:피자집  

n가지 토핑을 가질수있는 상태를 표현해야함.  
boolean배열을 사용해도 되지만, 비트 연산이 더많은 집합연산이 가능하다.  


##### *공집합과 꽉 찬 집합 구하기*  
    공집합: 0  
    꽉 찬 집합: 2^n-1  (eg. int fullPizza = (1<<n)-1; , 1<< n 의 뜻? 1뒤에 n개의 0이 있다는 뜻. 즉 n+1개의 비트에서 1을 빼주면 모두 1인 n개의 비트를 얻을 수 있음)  

##### *원소 추가*
p번 비트를 켠다.
```
toppings |= (1<<p);  
```
이미 값이 들어있을 경우 값은 변하지 않는다.  

##### *원소 포함 여부*  

```
if(toppings & (1<<p)) then ~
```

주의: 위 식은 0혹은 1<<p의 값을 반환한다. 그러므로

```
if(toppings & (1<<p) ==1) then ~
```
이런 식을 쓰면 안된다. (0,1을반환하는게 아니다.)
##### *원소의 삭제*  
```
toppings -= (1<<p);
```
위 식은 비트가 1<<p 위치의 비트값이 0일경우 문제가 생긴다.  
```
toppings &= ~(1<<p);
```
를 사용하자. ( p번 비트는 항상 꺼지고 나머지 비트는 toppings의 상태를 유지한다.)

##### *원소의 토글*  
```
toppings ^= (1<<p);
```
p번 토핑이 들어가 있는 경우 빼고, 빠져있는 경우 넣는다.  (서로 다른 비트일경우 킨다.)  

* 두 집합의 연산  
    두 개의 토핑집합 a와 b에 대하여..  
    ```
    int added = (a | b); // a와 b의 합집합
    int intersection = (a & b); // a와 b의 교집합
    int removed = (a & ~b); // a에서 b를 뺀 차집합
    int toggled = (a ^ b); // a와 b중 하나에만 포함된 원소들의 집합
    ```
* 집합의 크기 구하기  
    각 비트를 순회하면서 센다.  
    ```
    int bitCount(int x){
        if(x == 0) return 0;
        return x % 2 + bitCount(x / 2);
    }
    ```
    내장명령어 사용 가능(컴파일러 의존적, 빠름)
    ```
    gcc/g++ : __builtin_popcount(toppings)
    visual c++: __popcnt(toppings)
    ```
## 이부분 이해가 잘안간다.
* 최소 원소 찾기  
    "이 정수의 이진수 표현에서 끝에 붙어있는 0이 몇 개인가?"

    ```
    gcc/g++ : __builtin_ctz(toppings)
    visual c++ : _BitScanForward(&index,toppings)
    ```
    주의 : 입력이 0일시 undefined behavior  

    *직접구하기*
    ```
    int firstTopping = (toppings & -toppings);
    ```
    대부분의 컴퓨터가 2's complement를 용한다는 점을 이용한다.  
    2의 보수를 사용하는 시스템에서는 음수 -toppings를 표현하기 위해서 toppings에 비트별 NOT연산을 적용하고 그 결과에 1을 더한다. toppings에서 켜진 최하위 비트가 2^i라고 하자. 그러면 toppings의 마지막 u+1자리는 1뒤에 i개의 0이 있는 형태여야 한다. toppings에 비트별 NOT연산을 적용하면 마지막 i+1자리는 0뒤에 i개의 1이 있는 형태가 되고, 여기에 1을 더하면 다시 1과 i개의 0이 있는 형태가 된다. 2^i보다 상위 비트들에는 NOT 연산이 적용된 상태이므로 두 수를 AND하면 항상 최하위 비트만을 얻을 수 있다. 이 기법은 펜윅트리에서 유용하게 쓰인다.  

* 최소 원소 지우기  
    ```
    toppings &= (toppings-1);
    ```
    toppings-1의 이진수 표현은 toppings에서 켜져 있는 최하위 비트를 끄고 그 밑의 비트들을 전부 켠 것이다. 따라서 두 값을 비트별 AND연산하면 최하위 비트와 그 이하의 비트들은 전부 0이 된다.  
    ```
    40( 10 1000 ) & 39 ( 10 0111) = 32( 10 0000)
    ```
    이는 어떤 정수가 2의 거듭제곱 값인지 확인할 때 유용하게 쓰인다.  최하위 비트값을 지웠을때 0이되면 2의 거듭제곱값이다.

* 모든 부분 집합 순회하기
    ```
    for(int subset = pizza; subset; subset = ((subset-1) & pizza)){}
    ```
    subset에서 1을 빼면 켜져있던 최하위 비트가 꺼지고, 그 밑의 비트들은 전부 켜진다. 이 결과와 pizza의 교집합을 구하면 그 중 pizza에 속하지 않는 비트들은 모두 꺼지게 된다. 이 연산을 반복하면 pizza의 모든 부분 집합을 방문할 수 있다. subset이 0인 시점에 종료되기 때문에 공집합은 방문하지 않는다.  
    boolean값 배열을 통해 구현하면 재귀를 작성해야 하기 때문에 이쪽이 훨씬 간단하다.  
    

